## What is an Aggregate

An Aggregate is a group (a cluster) of objects that work together and are treated as a unit, to provide a specific functionality. It is the main building block of a business model. If you need more information about Aggregates, you can find it in the [“Big Blue Book”](http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215) or [on the web](http://blog.sapiensworks.com/post/2012/04/18/DDD-Aggregates-And-Aggregates-Root-Explained.aspx).

Typically, when you implement the CQRS pattern, the classes in the write model define your aggregates. Aggregates are recipients of commands and units of persistence. After an aggregate instance has processed a command and applied events produced, Spine saves the new Aggregate state to a [storage](../data-storage/index.md).

### How to Define an Aggregate

In Spine, an Aggregate consists from its [state](../biz-model/aggregate-states.md) defined as a protobuf message and a Java class which manages this state. 
The main steps to define an Aggregate are:

* Select a type for identifiers of the aggregates. If you select to use a typed identifier (which is recommended), you need to define a protobuf message for the ID type.
* Define an aggregate state structure as a protobuf message.
* Generate Java code for the ID and state types.
* Create a new Aggregate class derived from [org.spine3.server.aggregate.Aggregate](https://github.com/SpineEventEngine/core-java/blob/master/server/src/main/java/org/spine3/server/aggregate/Aggregate.java) passing the ID and state type parameters.

#### Constructor 

An Aggregate must have a public constructor initializing an Aggregate ID. It must be public as it serves as a public API for Spine (it is used by the Repository). TODO: add article about Aggregate Repository.

public OrderAggregate(OrderId id) {
        super(id);
}

### Aggregate Definition

An **aggregate** root should be inherited from the Spine abstract `Aggregate` class. And have two parameters defined: Aggregate Identifier and  Aggregate State.

```java
public class OrderAggregate extends Aggregate<OrderId, Order> {
}
```
**Note** that only the aggregate root needs to implement the Aggregate abstract class and other abstract classes mentioned below. The other entities that are part of the aggregate do not have to implement any interfaces.

### Aggregate Initialization
A new instance of the aggregate should be initialized using a `Constructor`. Constructor method should be `public` as it serves as a public API for Spine. With its help new instances of the aggregate will be added to the Aggregate Repository`TODO: add article about Aggregate Repository`. 
```java
 public OrderAggregate(OrderId id) {
        super(id);
}
```

### Command Handler
An aggregate usually contains at least one [Command Handler](./command-handler.md) method that defines what Events will be created as a result of the command execution. 

A Command Handler method is used with `@Assign` annotation. See an example of the Command Handler of the`OrderAggregate`:

```java
 @Assign
    public List<Message> handle(RegisterToConference command, CommandContext context) {
        checkNotConfirmed(getState(), command);
        validateCommand(command);

        final ImmutableList.Builder<Message> result = ImmutableList.builder();
        final boolean isNew = getVersion() == 0;
        if (isNew) {
            final OrderPlaced placed = EventFactory.orderPlaced(command);
            result.add(placed);
        } else {
            final OrderUpdated updated = EventFactory.orderUpdated(command);
            result.add(updated);
        }
        final OrderTotalsCalculated totalsCalculated = buildOrderTotalsCalculated(command.getOrderId(),
                command.getConferenceId(), command.getSeatList());
        result.add(totalsCalculated);
        return result.build();
    }
```
### Event Applier
Event applier is a method of an aggregate root which applies data from an event to the state of the aggregate.

Event appliers is not a public API of aggregate roots. As such they are declared private by convention set in the Spine framework:

``````java
 @Apply
 private void on(MyEvent event) {
     MyState newState = getState().toBuilder()
       .setMyProperty(event.getProperty())
       .build();
     validate(newState);
     setState(newState);
 }
``````
By default an Event applier should be created for each Event generated by the aggregate. But if there is an Event that does not mutate aggregate’s state, the Event applier for it may not be created. 
This behavior could be re-defined by using a method that returns state neutral event classes. 
```java
private static final ImmutableSet<Class<? extends Message>> STATE_NEUTRAL_EVENT_CLASSES =
            ImmutableSet.<Class<? extends Message>>of(
                    OrderTotalsCalculated.class, OrderExpired.class, OrderRegistrantAssigned.class);
```